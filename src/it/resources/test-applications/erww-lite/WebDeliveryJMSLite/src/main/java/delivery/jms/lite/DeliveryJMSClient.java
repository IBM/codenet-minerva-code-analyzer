package delivery.jms.lite;

/**
 * Insert the type's description here. Creation date: (10/11/00 6:24:35 PM)
 * 
 * @author: Administrator
 */
import irwwbase.ExtendedRandom;
import irwwbase.IRWWBase;
import irwwbase.MaxValues;

import java.util.UUID;

import jakarta.jms.QueueConnection;
import jakarta.jms.QueueConnectionFactory;
import jakarta.jms.QueueReceiver;
import jakarta.jms.QueueSender;
import jakarta.jms.JMSException;
import jakarta.jms.MapMessage;
import jakarta.jms.Message;
import jakarta.jms.ObjectMessage;
import jakarta.jms.Queue;
import jakarta.jms.QueueSession;
import jakarta.jms.TemporaryQueue;
import jakarta.jms.TextMessage;
import jakarta.jms.Topic;
import jakarta.jms.TopicConnection;
import jakarta.jms.TopicConnectionFactory;
import jakarta.jms.TopicSession;
import jakarta.jms.TopicSubscriber;
import javax.naming.InitialContext;

import deliverysession.DeliveryInput;
import deliverysession.DeliveryOutput;

public class DeliveryJMSClient extends IRWWBase{ 

	/**
	 * Autogenerated UID
	 */
	private static final long serialVersionUID = 75087103179490145L;

	public java.lang.String output;

	private short warehouseId = 0;

	private short carrierId = 0;

	private DeliveryInput input = null;

	private boolean distributed = true;

	private String deliveryTs = null;

	private QueueSender queueSender;

	private TopicSubscriber topicSubscriber;

	private QueueReceiver queueReceiver;

	private TemporaryQueue tempQ;

	private QueueSession queueSession;
	private TopicSession topicSession;

	private QueueConnection queueConnection;
	private TopicConnection topicConnection;

	private boolean jsFlow;
	
	private DeliveryOutput DeOutput = null;

	/**
	 * DeliveryClient constructor comment.
	 */
	public DeliveryJMSClient() {
		super();
	}

	/**
	 * Insert the method's description here. Creation date: (10/11/00 7:30:42
	 * PM)
	 * 
	 * @return deliverySessionPackage.DeliveryInputInfo
	 * @param db
	 *            byte
	 */
	public DeliveryInput generateDeliveryInput(byte db) {
		
		debugOut("<< Enter generateDeliveryInput() in JMS Delivery client >");

		ExtendedRandom rand = new ExtendedRandom();

		DeliveryInput input = new DeliveryInput();
		carrierId = (short) rand.nextInt(1, MaxValues.carrierId(db));
		input.setCarrierId(carrierId);
		warehouseId = (short) rand.nextInt(1, MaxValues.warehouseId(db));
		input.setWarehouseId(warehouseId);
		input.setMaxdistrictId(MaxValues.districtId(db));
		
		debugOut("<< Exit generateDeliveryInput() in JMS Delivery client >");
		
		return input;
	}

	/**
	 * Insert the method's description here. Creation date: (10/2/2001 3:28:44
	 * PM)
	 * 
	 * @return java.lang.String
	 */
	public java.lang.String getOutput() {
		return output;
	}

	
	/**
	 * Insert the method's description here. Creation date: (10/2/2001 3:28:44
	 * PM)
	 * 
	 * @param newOutput
	 *            java.lang.String
	 */
	public void setOutput(java.lang.String newOutput) {
		output = newOutput;
	}

	/**
	 * Insert the method's description here. Creation date: (10/2/2001 3:24:38
	 * PM)
	 */
	public void webAutoGenInput() throws Exception {
		
		try {

			debugOut("< Enter JMS Delivery client webAutoGenInput() >");
			debugOut("< Starting Time is: " + new java.util.Date().toString()
					+ ", milliseconds: " + String.valueOf(System.currentTimeMillis()));

			byte database = (byte) 1;
			database = dbSize();

			input = this.generateDeliveryInput(database);

			// Now invoke the main business logic
			webBusinessLogic();

		} finally {

			displayOut("Ending Time is: " + new java.util.Date().toString()
					+ ", milliseconds: " + String.valueOf(System.currentTimeMillis()));		
			debugOut("< Exit JMS Delivery client webAutoGenInput() >");
		}

	}

	/**
	 * Insert the method's description here. Creation date: (10/2/2001 3:24:38
	 * PM)
	 */
	public void webManualInput() throws Exception {

		try {
			
			debugOut("< Enter JMS Delivery client webManualInput() >");
			debugOut("< Starting Time is: " + new java.util.Date().toString()
					+ ", milliseconds: " + String.valueOf(System.currentTimeMillis()));

			input = new DeliveryInput();
			input.setMaxdistrictId(10);	

			if (getWarehouseId() != 0) {
				input.setWarehouseId(getWarehouseId());
			}

			if (getCarrierId() != 0) {
				input.setCarrierId(getCarrierId());
			}

			input.setDistributedEJBs(isDistributed());

			// Now invoke the main business logic
			webBusinessLogic();

		} finally {

			debugOut("< Ending Time is: " + new java.util.Date().toString()
					+ ", milliseconds: " + String.valueOf(System.currentTimeMillis()));
			debugOut("< Exit JMS Delivery client webManualInput() >");
		}

	}

	/**
	 * Gets the warehouseId
	 * 
	 * @return Returns a short
	 */
	public short getWarehouseId() {
		return warehouseId;
	}

	/**
	 * Sets the warehouseId
	 * 
	 * @param warehouseId
	 *            The warehouseId to set
	 */
	public void setWarehouseId(short warehouseId) {
		this.warehouseId = warehouseId;
	}

	/**
	 * Gets the carrierId
	 * 
	 * @return Returns a short
	 */
	public short getCarrierId() {
		return carrierId;
	}

	/**
	 * Sets the carrierId
	 * 
	 * @param carrierId
	 *            The carrierId to set
	 */
	public void setCarrierId(short carrierId) {
		this.carrierId = carrierId;
	}

	private void webBusinessLogic() throws Exception {
		
		setOutput(null);
		
		QueueConnectionFactory queueConnectionFactory = null;
		TopicConnectionFactory topicConnectionFactory = null;
		
		Queue queue = null;
	 	Topic topic = null;
		MapMessage message = null;
		String replyString = null;
		String selectorUUID = null;
		String topicSelector = null;
		
		// Outer try block to guarantee cleanup is called no mater how far we
		// get or don't get in this method
		try {
			debugOut("<< Enter JMS Delivery client webBusinessLogic() >>");

			// lookup JMS resources in JNDI
			try {

				InitialContext context = new InitialContext();

				queueConnectionFactory = (QueueConnectionFactory) context.lookup("java:comp/env/jms/DeliveryQueueCF");	
				topicConnectionFactory = (TopicConnectionFactory) context.lookup("java:comp/env/jms/DeliveryTopicCF");		

				queue = (Queue) context.lookup("java:comp/env/jms/DeliveryRequestQueue");
				topic = (Topic) context.lookup("java:comp/env/jms/DeliveryLogTopic");

			} catch (Exception e){
				System.out.println("Naming lookup exception in processMDB() in DeliveryJMSClient: " + e.getMessage());
				if (e.getCause() != null) {
					Throwable nestedExc = e.getCause();
					nestedExc.printStackTrace();
					throw new Exception("Naming lookup exception in processMDB() in DeliveryJMSClient: " + nestedExc.getMessage());
				} else {
					e.printStackTrace();
					throw new Exception("Naming lookup exception in processMDB() in DeliveryJMSClient: " + e.getMessage());
				}
			}

			try {
				queueConnection = queueConnectionFactory.createQueueConnection();
				queueConnection.start();

				topicConnection = topicConnectionFactory.createTopicConnection();
				topicConnection.start();

				queueSession = queueConnection.createQueueSession(false, QueueSession.AUTO_ACKNOWLEDGE);
				topicSession = topicConnection.createTopicSession(false, TopicSession.AUTO_ACKNOWLEDGE);

				queueSender = queueSession.createSender(queue);

				deliveryTs = String.valueOf(System.currentTimeMillis());

				debugOut("<< Input values in JMS Delivery client...");
				debugOut("<<< warehouseId: " + input.getWarehouseId());
				debugOut("<<< carrierId: " + input.getCarrierId());
				debugOut("<<< maxDistrictId: " + input.getMaxdistrictId());
				debugOut("<<< jsflow: " + isJsFlow());
				debugOut("<<< deliveryTS: " + deliveryTs);

				tempQ = queueSession.createTemporaryQueue();

				queueReceiver = queueSession.createReceiver(tempQ);

			} catch (Exception e) {
				System.out.println("JMS resource create exception in processMDB() in DeliveryJMSClient: " + e.getMessage());
				if (e.getCause() != null) {
					Throwable nestedExc = e.getCause();
					nestedExc.printStackTrace();
					throw new Exception("JMS resource create exception in processMDB() in DeliveryJMSClient: " + nestedExc.getMessage());
				} else {
					e.printStackTrace();
					throw new Exception("JMS resource create exception in processMDB() in DeliveryJMSClient: " + e.getMessage());
				}								
			}	

			try {
				
				// Subscribe to deliveryLogTopic here, create a UUID for the selector so that
				// we can create the subscriber before the MDB even starts to run.  The
				// subscriber must be created before the MDB publishes to the topic
				// or we risk missing it (ie. publishing a message to a topic when there
				// are no active subscribers causes the message to be discarded by JMS).
				selectorUUID = (UUID.randomUUID()).toString();
				debugOut("<< Selector UUID for this client bean is: " + selectorUUID);
				
				//MLS temporary fix for MQ bug with selectors.   Make my own custom property
				// for the correlation ID instead of using the predefined message field
				// called JMSCorrelationID.
				//String topicSelector = "JMSCorrelationID = '" + firstSentMsgID + "'";
				topicSelector = "ERWWCorrelationID = '" + selectorUUID + "'";
				topicSubscriber = topicSession.createSubscriber(topic, topicSelector, false);
				
				// build the client request message that will trigger the MDB 	
				message = queueSession.createMapMessage();
				message.setShort("warehouseId", input.getWarehouseId());
				message.setShort("carrierId", input.getCarrierId());
				message.setInt("maxDistrictId", input.getMaxdistrictId());
				message.setBoolean("jsFlow", isJsFlow());
				message.setString("deliveryTs", deliveryTs);
				message.setJMSReplyTo(tempQ);
				message.setStringProperty("JSFlowMsgType", "Delivery");
				message.setStringProperty("ERWWCorrelationID", selectorUUID);

				debugOut("<< Queue name where client message will be sent: " + queue.getQueueName());
				debugOut("<< Sending client message now...");

				// send the client message
				queueSender.send(message);
				debugOut("<< Dump of Msg Delivery client sent: " + message.toString());

			} catch (Exception e) {
				System.out.println("JMS message send exception in processMDB() in DeliveryJMSClient: " + e.getMessage());
				if (e.getCause() != null) {
					Throwable nestedExc = e.getCause();
					nestedExc.printStackTrace();
					throw new Exception("JMS message send exception in processMDB() in DeliveryJMSClient: " + nestedExc.getMessage());
				} else {
					e.printStackTrace();
					throw new Exception("JMS message send exception in processMDB() in DeliveryJMSClient: " + e.getMessage());
				}			
			}
				
			debugOut("<< Client waiting up to 3 minutes to receive Delivery acknowledge, current time = "
					+ new java.util.Date().toString());

			// wait up to 3 minutes (180,000 milliseconds) for first receive, ie. Delivery acknowledge from ME 
			long wait = 180000;

			try {
				Message inMessage = queueReceiver.receive(wait);
				if (inMessage != null) {
					replyString = ((TextMessage) inMessage).getText();
					debugOut("<< Client got delivery acknowledge: " + replyString);
					debugOut("<< Dump of Msg received by Delivery client: " + inMessage.toString());

				} else {
					//Print error message if Message was not a TextMessage.
					System.out.println("Timed out on Delivery acknowledge, start timestamp was: "
							+ deliveryTs + " selectorUUID was: " + selectorUUID);
					System.out.println("Timeout might be a runtime issue, or Delivery acknowledge may have taken too long if Messaging engine is very slow");
					throw new Exception("Timed out on Delivery acknowledge in DeliveryJMSClient");
				}

			} catch (Exception e) {		
				System.out.println("JMS message received exception waiting on Delivery acknowledge in DeliveryJMSClient: " + e.getMessage());
				if (e.getCause() != null) {
					Throwable nestedExc = e.getCause();
					nestedExc.printStackTrace();
					throw new Exception("JMS message received exception waiting on Delivery acknowledge in DeliveryJMSClient: " + nestedExc.getMessage());
				} else {
					e.printStackTrace();
					throw new Exception("JMS message received exception waiting on Delivery acknowledge in DeliveryJMSClient: " + e.getMessage());
				}
			}


			debugOut("<< Client waiting up to 3 minutes to receive Delivery output from queued transaction, current time = "
					+ new java.util.Date().toString());

			wait = 180000;   // 3 minutes = 180,000 milliseconds
			try {
				Message inMessage = queueReceiver.receive(wait);

				if (inMessage != null) {

					if ((inMessage.getBooleanProperty("RC")) == true) {	

						// If RTC is true the MDB executed fine so keep going
						debugOut("<< Return code in reply from Delivery MDB's execution said successful");

						if (inMessage instanceof ObjectMessage) {

							// This message should be of type ObjectMessage which contains a
							// serialized DeliveryOutput object coming back from the DelvieryMDB

							DeOutput = (DeliveryOutput) ((ObjectMessage)inMessage).getObject();
							debugOut("<< Client got delivery outcome");
							debugOut("<< Dump of Msg received by Delivery client: " + inMessage.toString());

						} else {

							// throw exception for unexpected message type
							debugOut("Received wrong message type for delivery output in DeliveryJMSClient");
							throw new Exception("Received wrong message type for delivery output in DeliveryJMSClient");
						}

					} else {

						// RC is false, the MDB had an exception and the exception
						// text was returned in response message we just receive.  Propagate
						// the exception text received to the client here.
						debugOut("<< Return code in reply from Delivery MDB's execution said failure occurred");

						if (inMessage instanceof TextMessage) {

							debugOut("<< Dump of Msg received by Delivery client: " + inMessage.toString());
							debugOut("<< Throwing exception with error text returned in reply message from Delivery MDB's execution");
							throw new Exception ( ((TextMessage)inMessage).getText() );

						} else {

							// throw exception for unexpected message type
							debugOut("<< Received wrong message type for delivery output in DeliveryJMSClient");
							throw new Exception("Received wrong message type for delivery output in DeliveryJMSClient");
						}
					}			


				} else {
					//Print error message if timed out, Message was null, or Message was not an ObjectMessage.
					debugOut("Timed out waiting on Delivery output in DeliveryJMSClient, selectorUUID was: " + selectorUUID);
					throw new Exception("Timed out waiting on Delivery output in DeliveryJMSClient");
				}

			} catch (Exception e) {
				System.out.println("JMS received exception waiting on Delivery output in DeliveryJMSClient: " + e.getMessage());
				if (e.getCause() != null) {
					Throwable nestedExc = e.getCause();
					nestedExc.printStackTrace();
					throw new Exception("JMS received exception waiting on Delivery output in DeliveryJMSClient: " + nestedExc.getMessage());
				} else {
					e.printStackTrace();
					throw new Exception("JMS received exception waiting on Delivery output in DeliveryJMSClient: " + e.getMessage());
				}				
			}

			wait = 180000;   // 3 minutes = 180,000 milliseconds
			debugOut("<< Client waiting up to 3 minutes to receive deliveryLogTopic output, current time = "
					+ new java.util.Date().toString());
			try {
				Message inMessage = topicSubscriber.receive(wait);
				if (inMessage != null) {
					debugOut("<< Client received deliveryLogTopic msg");
					debugOut("<< Dump of Msg that client consumed: " + inMessage.toString());
					replyString = replyString + "\n"
							+ "Data from DeliveryLogTopic subscriber: "
							+ ((TextMessage) inMessage).getText();
					debugOut("<< Complete String to post back on Client web page: " + replyString);

				} else {
					debugOut("Timed out waiting on deliveryLogTopic receive, with selector = " + topicSelector + " in DeliveryJMSClient");
					throw new Exception("Timed out waiting on deliveryLogTopic receive, with selector = " + topicSelector + " in DeliveryJMSClient");
				}

			} catch (Exception e) {
				System.out.println("JMS received exception waiting on deliveryLogTopic receive in DeliveryJMSClient: " + e.getMessage());
				if (e.getCause() != null) {
					Throwable nestedExc = e.getCause();
					nestedExc.printStackTrace();
					throw new Exception("JMS received exception waiting on deliveryLogTopic receive in DeliveryJMSClient: " + nestedExc.getMessage());
				} else {
					e.printStackTrace();
					throw new Exception("JMS received exception waiting on deliveryLogTopic receive in DeliveryJMSClient: " + e.getMessage());
				}		
			}

			debugOut("<< After Delivery client receive attempts are done, time = "
					+ new java.util.Date().toString());

			int x = 0;

			Message inMessage = null;
			debugOut("<< Client: before payment receive loop, jsFlow is: "+jsFlow);
			if (isJsFlow()) {
				try {
					wait = 120000;
					String verbage = null;
					x++;
					for (; x <= 10;) {
						inMessage = queueReceiver.receive(wait);
						if (inMessage == null) {
							verbage = "<<<Timed out waiting for replies from Payment on reply number "
									+ x + " deliveryTs=" + deliveryTs;
							break;
						}
						//else System.out.println("Payment reply number "+x+"
						// received: "+ts);
						String msgContent = ((TextMessage) inMessage).getText();
						if (msgContent
								.indexOf("PaymentMDB worked successfully!") != -1)
							x++;
						debugOut("Payment msg content back at DeliveryJMSClient is "
								+ msgContent);
					}
					x = x - 1;
					if (inMessage == null)
						System.out.println(verbage);
					else {
						debugOut("Completed processing Payment replies successfully, "
								+ x + " received");
						replyString = replyString + " " + x + " Payments made";
						queueReceiver.close();
						tempQ.delete();
					}

				} catch (Exception e) {
					System.out.println("Problem in payment flow in processMDB() in DeliveryJMSClient: " + e.getMessage());
					if (e.getCause() != null) {
						Throwable nestedExc = e.getCause();
						nestedExc.printStackTrace();
						throw new Exception("Problem in payment flow in processMDB() in DeliveryJMSClient: " + nestedExc.getMessage());
					} else {
						e.printStackTrace();
						throw new Exception("Problem in payment flow in processMDB() in DeliveryJMSClient: " + e.getMessage());
					}	
				}

				debugOut("<< Client: after payment receive loop");

			} // end if (isJsFlow())

            // end of normal (ie. good) path, set output.
			this.setOutput(replyString);
			

		} finally {

			// no matter how we exit cleanup all JMS resources used 
			cleanup();
			debugOut("<< Exit JMS Delivery client webBusinessLogic() >>");
		}

	}

	/**
	 * @return
	 */
	public boolean isDistributed() {
		return distributed;
	}

	/**
	 * @param b
	 */
	public void setDistributed(boolean b) {
		distributed = b;
	}

	private void cleanup() throws Exception {
		
		// cleanup may be called on resources that have not been initialize
		// so be sure to check null first!
		
		try {	
			debugOut("<<< Enter cleanup() to close down JMS resources");
			
			if (queueSender!=null) queueSender.close();
			if (topicSubscriber!=null) topicSubscriber.close();
			if (queueReceiver!=null) queueReceiver.close();
			if (queueSession!=null) queueSession.close();
			if (topicSession!=null) topicSession.close();
			if (queueConnection!=null) queueConnection.close();
			if (topicConnection!=null) topicConnection.close();
			
		} catch (JMSException j) {
			debugOut("<<< Caught JMSException in cleanup(): " + j.getMessage());
			j.printStackTrace();
			Exception e = j.getLinkedException();
			if (e != null) {
				throw new Exception("Caught JMSException in cleanup()", e);
			} else {
				throw new Exception("Caught JMSException in cleanup()", j);
			}
			
		} catch (Exception e) {
			debugOut("<<< Caught Exception in cleanup(): " + e.getMessage());
			e.printStackTrace();
			throw new Exception("Caught Exception in cleanup()", e); 

		} finally {
			debugOut("<<< Exit cleanup() after closing down JMS resources");
		}
	}


	public boolean isJsFlow() {
		return jsFlow;
	}

	public void setJsFlow(boolean jsFlow) {
		this.jsFlow = jsFlow;
	}
	
	public DeliveryOutput getDeliveryOutput() {
		return DeOutput;
	}
	
}