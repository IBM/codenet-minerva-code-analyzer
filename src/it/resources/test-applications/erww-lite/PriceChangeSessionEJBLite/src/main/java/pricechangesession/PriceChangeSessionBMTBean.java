package pricechangesession;

import irwwbase.IRWWBase;
import irwwbase.UserException;
import itemjpa.ItemJPA;

import java.math.BigDecimal;
import java.math.RoundingMode;

//import jakarta.annotation.PostConstruct;
import jakarta.annotation.Resource;
import jakarta.annotation.security.DeclareRoles;
//import jakarta.annotation.security.RolesAllowed;
//import jakarta.annotation.security.RunAs;
import jakarta.ejb.EJBException;
//import jakarta.ejb.Local;
import jakarta.ejb.LocalBean;
//import jakarta.ejb.Remote;
//import jakarta.ejb.RemoteHome;
import jakarta.ejb.SessionContext;
import jakarta.ejb.Stateless;
import jakarta.ejb.TransactionManagement;
import jakarta.ejb.TransactionManagementType;
import jakarta.enterprise.event.Event;
import jakarta.enterprise.inject.Any;
import jakarta.enterprise.inject.Default;
import jakarta.inject.Inject;
//import jakarta.interceptor.Interceptors;
//import javax.naming.InitialContext;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.UserTransaction;

import pc.transaction.event.TransactionEvent;
//import produce.ejb.PCEntityManagerQualifier;

//Comment out unused import
//import com.ibm.websphere.cache.DistributedMap;
//import com.ibm.websphere.cache.DynamicCacheAccessor;

// shupert - minor cleanup to make it clear this bean has 
//           a remote business interface and an EJB 3.1
//           no-interface view (ie. @LocalBean)
@Stateless
@LocalBean
@DeclareRoles("PRICECHANGER")
@TransactionManagement(TransactionManagementType.BEAN)
public class PriceChangeSessionBMTBean extends IRWWBase {
	
	/**
	 * Autogenerated UID
	 */
	private static final long serialVersionUID = 244317418712204470L;

	@Resource private SessionContext ctx;
	
	@PersistenceContext(unitName = "PriceChangeEJB")
	EntityManager em;
	
	// waiting for task 34449 to complete - NIV bean support
	//@Inject @My private EntityManager em;
	
	 @Inject private @Any @Default Event<TransactionEvent> transactionEvent;

	ItemJPA itemJPA = null;
	
	public PriceChangeOutput priceChangeSession(ItemJPA input) throws UserException {
		
		startOfTran("PriceChangeSessionEJB3 BMT Version");
		
		PriceChangeOutput output = new PriceChangeOutput();
		//Comment out two unused variables
		//DistributedMap map = null;
		//int maxNumberOfItemIds = 15;
		TransactionEvent event=null;

		debugOut("Running PriceChangeSessionBMT priceChangeSession()");
		
		UserTransaction ut = ctx.getUserTransaction();

		try {
			ut.begin();
			debugOut("FacadeBean 1");
			//OpenJPAEntityManager kem = OpenJPAPersistence.cast(em);
			//kem.getFetchPlan().setReadLockMode(LockModeType.WRITE);
			itemJPA = em.find(ItemJPA.class, input.getItemId());
			//kem.getFetchPlan().setReadLockMode(null);

			if (itemJPA != null) {

				debugOut("FacadeBean 2");
				
				if (Double.valueOf(input.getItemPrice().toString())>=1000) {
					System.out.println("<<< Somehow itemPrice exceeded 999.99, itemPrice ="+input.getItemPrice()+" resetting to 999.99");
					input.setItemPrice(new BigDecimal(999.99));
				}
				
				BigDecimal itemPrice = new BigDecimal(input
					.getItemPrice().toString()).setScale(2,
					RoundingMode.DOWN);

				debugOut("FacadeBean 3");
				itemJPA.setItemPrice(itemPrice);
				debugOut("FacadeBean 4");
				if (em.contains(itemJPA))
					debugOut("mgd_");

				debugOut(" item entity values, itemId: " + itemJPA.getItemId()
					+ " price: " + itemJPA.getItemPrice());
			} else
				throw new UserException("item not found, item="+input.getItemId()+", "+getSTC(),"no stack");
			event = new TransactionEvent();
	        transactionEvent.fire(event);
			
			ut.commit();
		
			//additions by surya
			itemJPA.setStcnum(irwwbase.Stcnum.getInstance().getStcnum());
			// end
		} catch (Exception e) {
			if (is913(e))
				throw new UserException("<&!@"+checkFor913(e)+", finding Item JPA, "+ e.getCause()+getSTC(), getStackTrace(e));
			else throw new UserException("<&!@"+"Error while processing PriceChange, "+" exception message: "+e.getMessage()+", exception cause: "+ e.getCause()+getSTC(),getStackTrace(e));
			
		}
		output.setItem(itemJPA);
		
		endOfTran("PriceChangeSessionEJB3");
		
		String eMessage=event.getMessages();
		
		java.io.FileWriter resultFile = null;
		try {
			resultFile = new java.io.FileWriter("priceChangeEvents.log");
			logResultFile("Events: " + eMessage, resultFile);
		} catch (Exception ex) {
			System.out.println("%%%%% ERROR: resultFile = new java.io.FileWriter(results.out) ");
			ex.printStackTrace();
			throw new EJBException("%%%%% ERROR: resultFile = new java.io.FileWriter(results.out) failed  ",ex);
		} finally {
			try {
				resultFile.close();
			} catch (Exception e) {
				System.out.println("%%%%% ERROR: resultFile failed to close.  Exception = " + e);
				e.printStackTrace();
				throw new EJBException("%%%%% ERROR: resultFile failed to close", e);
			}
		}  
		
		return output;

	}

	public void debugOut(String message) {

		if (System.getProperty("DEBUG_OUT") != null)
			if (System.getProperty("DEBUG_OUT").equals("ON"))
				System.out.println(message);
	}
	
	
}